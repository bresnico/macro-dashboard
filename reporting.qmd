---
title: "Bilan de passation JDR"
format: 
  html:
    toc: true
    theme: default
    df-print: paged
server: shiny
---

```{r}
#| context: setup

# Chargement des packages
suppressPackageStartupMessages({
  library(tidyverse)
  library(DT)
  library(shiny)
})

# Chargement des donnÃ©es
get_survey_data <- function() {
  tryCatch({
    files <- list.files(
      "data/processed",
      pattern = "^survey_data_.*\\.csv$",
      full.names = TRUE
    )
    if(length(files) == 0) {
      stop("No data files found")
    }
    
    latest_index <- which.max(file.info(files)$mtime)
    latest_file <- files[latest_index]
    latest_date <- format(file.info(files)$mtime[latest_index],
                         format = "%H:%M",
                         tz = "Europe/Paris")
    
    list(
      data = read_csv(latest_file, 
                     locale = locale(encoding = "UTF-8"),
                     show_col_types = FALSE),
      update_time = latest_date
    )
  }, error = function(e) {
    warning(paste("Error loading data:", e$message))
    return(list(data = NULL, update_time = NULL))
  })
}

# Usage
survey_data <- get_survey_data()
data <- survey_data$data
update_time <- survey_data$update_time

# Fonction de calcul du score standardisÃ©

calculate_standard_score <- function(score_value, min_value, max_value) {
  ((score_value - min_value) / (max_value - min_value)) * 100
}

# Fonction utilitaire pour crÃ©er les datatables

create_jdr_datatable <- function(data, categories, detailed = FALSE) {
  # SÃ©lection initiale diffÃ©rente selon le mode
  if (detailed) {
    data_filtered <- data %>%
      filter(category %in% categories) %>%
      mutate(
        score_standard = calculate_standard_score(score_value, min_value, max_value)
        ) %>%
        group_by(scale_label) %>%
        arrange(desc(score_standard), .by_group = TRUE) %>%
        ungroup() %>%
      select(
        Ã‰chelle = scale_label,
        Dimension = score_label,
        `Score personnel` = score_value,
        `Score standardisÃ©` = score_standard,
        `Moyenne Ã©quipe` = team_mean,
        `Moyenne Ã©tablissement` = school_mean,
        quartile_position,
        team_quartile_position,
        school_quartile_position
      )
  } else {
    data_filtered <- data %>%
      filter(category %in% categories) %>%
      mutate(
        score_standard = calculate_standard_score(score_value, min_value, max_value)
        ) %>%
        group_by(scale_label) %>%
        arrange(desc(score_standard), .by_group = TRUE) %>%
        ungroup() %>%      
      select(
        Ã‰chelle = scale_label,
        Dimension = score_label,
        `Score personnel` = score_value,
        `Score standardisÃ©` = score_standard,
        `Moyenne Ã©quipe` = team_mean,
        `Moyenne Ã©tablissement` = school_mean,
        quartile_position
      )
  }
  
  # Ajouter les ronds de couleur pour les quartiles
  data_filtered <- data_filtered %>%
    mutate(
      Quartile = case_when(
        quartile_position == 1 ~ "ðŸ”´",
        quartile_position == 2 ~ "ðŸŸ ",
        quartile_position == 3 ~ "ðŸŸ¡",
        quartile_position == 4 ~ "ðŸŸ¢",
        TRUE ~ "âšª"
      )
    )
  
  if (detailed) {
    # Ajouter les quartiles Ã©quipe et Ã©tablissement
    data_filtered <- data_filtered %>%
      mutate(
        `Quartile Ã©quipe` = case_when(
          team_quartile_position == 1 ~ "ðŸ”´",
          team_quartile_position == 2 ~ "ðŸŸ ",
          team_quartile_position == 3 ~ "ðŸŸ¡",
          team_quartile_position == 4 ~ "ðŸŸ¢",
          TRUE ~ "âšª"
        ),
        `Quartile Ã©tablissement` = case_when(
          school_quartile_position == 1 ~ "ðŸ”´",
          school_quartile_position == 2 ~ "ðŸŸ ",
          school_quartile_position == 3 ~ "ðŸŸ¡",
          school_quartile_position == 4 ~ "ðŸŸ¢",
          TRUE ~ "âšª"
        )
      ) %>%
      # Supprimer les colonnes temporaires
      select(-team_quartile_position, -school_quartile_position)
  }
  
  # RÃ©organisation finale des colonnes
  data_filtered <- data_filtered %>%
    select(Quartile, Ã‰chelle, Dimension, everything(), -quartile_position)
  
  # CrÃ©ation de la table avec regroupement
  dt <- datatable(
    data_filtered,
    rownames = FALSE,
    extensions = c("RowGroup", "Buttons"),
    options = list(
      language = list(
        info = 'Yeah, il y a _TOTAL_ scores de _START_ Ã  _END_',
        paginate = list(previous = 'Avant', `next` = 'AprÃ¨s'),
        search = "Rechercher"
        ),
      pageLength = 20,
      dom = 'Bfrtip',
      ordering = FALSE,
      rowGroup = list(
        dataSrc = 1  # Index de la colonne 'Ã‰chelle' (0-based)
      ),
      columnDefs = list(
        list(visible = FALSE, targets = 1)  # Cache la colonne 'Ã‰chelle'
      ),
      buttons = list( # Configuration des boutons d'export
        list(
          extend = "copy",
          text = "Copier",
          titleAttr = "Copier dans le presse-papier"
        ),
        'csv',
        'pdf',
        list(
          extend ='colvis',
          text = "VisibilitÃ©",
          titleAttr = "VisibilitÃ© des colonnes"
        )
      )
    )
  ) %>%
    formatRound(
      columns = c('Score personnel', 'Score standardisÃ©', 'Moyenne Ã©quipe', 'Moyenne Ã©tablissement'), 
      digits = 2
    )
  
  return(dt)
}

```

## Mise Ã  jour des donnÃ©es {.unnumbered}

```{r}

uiOutput("update_time_ui")
```

## To do list [work in progress]

- vÃ©rifier que tous les scores sont tournÃ©s dans le mÃªme sens cÃ d que plus le score est haut, meilleur il est pour la personne (donc le score de colÃ¨re est mauvais quand il dit 1 sur 6 et bon quand il a 5 sur 6) --> les feux sont toujours valables.

    - formuler un "guide de lecture" du rapport
    - documenter ce choix stratÃ©gique qui influence scales.yml. (readme de github)
    - vÃ©rifier chaque Ã©chelles dans le docx pour s'assurer que les scores sont bien dans le bon sens attendu

- changer le lien Ã  competences-emotionnelles.ch et choisir un autre domaine
- scores nommÃ©s

    - enlever "score global" et inscrire comme "sous-score" dans le yaml
    - gÃ©rer / fusionner qaes 1 et 2.
   
- ajouter feux rouge, orange foncÃ©, orange clair, vert

    - Equipe :
    
        - pas de calcul des scores si <10 
        - pas de calcul des scores si Ã©quipe est non renseignÃ©
    
    - Etablissement :
    
        - pas de calcul des scores si <10 
        - pas de calcul des scores si Ã©tablissement est non renseignÃ©
    
- Sortir TIPI du rapport
- rapport prof
    
    - dÃ©cider contenu de "vue simple" "vue dÃ©taillÃ©e"

- DT
   
   - traduire les boutons (list = ...)

- rapport CD (DIR)

    - GÃ©nÃ©ral pour l'Ã©tablissement 
    - Equipe par Ã©quipe (avec filtre)
    - Selon filtres dÃ©mo
    - vÃ©rifier si on fait un "nouveau" shiny ou bien si on ajoute un onglet "direction" Ã  l'existant

## Identification

```{r}
textInput("person_id_input", "Entrez votre identifiant :", value = "", placeholder = "01NS14-artichaut")

uiOutput("person_id_status")

```

## DonnÃ©es dÃ©mographiques

```{r}
DTOutput("demo_table")
```

## RÃ©sultats

### Contraintes individuelles et organisationnelles

:::: {.panel-tabset}

##### Vue simple

```{r}
DTOutput("constraints_table_simple")
```

##### Vue dÃ©taillÃ©e

```{r}
DTOutput("constraints_table_detailed")
```

::::

### Ressources individuelles et organisationnelles

:::: {.panel-tabset}

##### Vue simple

```{r}
DTOutput("resources_table_simple")
```

##### Vue dÃ©taillÃ©e

```{r}
DTOutput("resources_table_detailed")
```

::::

### QualitÃ© de vie au travail

:::: {.panel-tabset}

##### Vue simple

```{r}
DTOutput("qvt_table_simple")
```

##### Vue dÃ©taillÃ©e

```{r}
DTOutput("qvt_table_detailed")
```

::::

### Ã‰panouissement et fonctionnement optimal

:::: {.panel-tabset}

##### Vue simple

```{r}
DTOutput("epfo_table_simple")
```

##### Vue dÃ©taillÃ©e

```{r}
DTOutput("epfo_table_detailed")
```

::::

```{r}
#| context: server

# Affichage de l'heure de mise Ã  jour des donnÃ©es

output$update_time_ui <- renderUI({
  div(
    style = "color: #666; font-size: 0.9em; margin: -10px 0 20px 0;",
    icon("clock"), 
    paste("DerniÃ¨re mise Ã  jour des donnÃ©es :", update_time)
  )
})

# Validation de l'ID
output$person_id_status <- renderUI({
  req(input$person_id_input)
  valid_person_id <- any(data$person_id == input$person_id_input, na.rm = TRUE)
  
  if(valid_person_id) {
    tagList(
      div(style = "color: green;", icon("check-circle"), "Identifiant valide"),
    )
  } else {
    div(style = "color: red;", icon("exclamation-circle"), 
        "Identifiant non reconnu")
  }
})

# DÃ©finition des catÃ©gories
categories <- list(
  "constraints" = c("CI", "CO"),
  "resources" = c("RI", "RO"),
  "qvt" = c("EMO", "TROUBLES", "MOT"),
  "epfo" = c("EFF", "BIENETRE", "SAT", "PER", "ATT")
)

# DonnÃ©es filtrÃ©es selon l'ID
filtered_data <- reactive({
  req(input$person_id_input)
  validate(need(nchar(input$person_id_input) > 0, ""))
  
  user_data <- data %>%
    filter(person_id == input$person_id_input)
  
  validate(need(nrow(user_data) > 0, "Veuillez entrer un identifiant valide."))
  
  user_data
})

# Table dÃ©mographique
output$demo_table <- renderDT({
  req(filtered_data())
  
  filtered_data() %>%
    select(person_id, age, gender, status, experience, school_label, team_label) %>%
    distinct() %>%
    rename(
      `Identifiant` = person_id,
      Ã‚ge = age,
      Genre = gender,
      Statut = status,
      ExpÃ©rience = experience,
      `Ã‰tablissement` = school_label,
      `Ã‰quipe` = team_label
    ) %>%
    datatable(options = list(dom = 't'), rownames = FALSE)
})

# Outputs pour les contraintes
output$constraints_table_simple <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$constraints, detailed = FALSE)
})

output$constraints_table_detailed <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$constraints, detailed = TRUE)
})

# Outputs pour les ressources
output$resources_table_simple <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$resources, detailed = FALSE)
})

output$resources_table_detailed <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$resources, detailed = TRUE)
})

# Outputs pour la qualitÃ© de vie au travail
output$qvt_table_simple <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$qvt, detailed = FALSE)
})

output$qvt_table_detailed <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$qvt, detailed = TRUE)
})

# Outputs pour l'Ã©panouissement
output$epfo_table_simple <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$epfo, detailed = FALSE)
})

output$epfo_table_detailed <- renderDT({
  req(filtered_data())
  create_jdr_datatable(filtered_data(), categories$epfo, detailed = TRUE)
})
```