---
title: "Plateforme de suivi du développement professionnel"
format:
  dashboard:
    theme: morph
    nav-buttons: [github]
server: shiny
---


```{r}
#| context: setup

library(tidyverse)
library(plotly)
library(shiny)
library(DT)
library(bslib)
library(bsicons)

get_latest_survey_data <- function() {
  files <- list.files("data/processed",
                      pattern = "^survey_data_.*\\.csv$",
                      full.names = TRUE)
  latest_file <- files[which.max(file.info(files)$mtime)]
  read_csv(latest_file, locale = locale(encoding = "UTF-8"))
}

data <- get_latest_survey_data()

get_survey_data_update_date <- function() {
  files <- list.files("data/processed", 
                     pattern = "^survey_data_.*\\.csv$",
                     full.names = TRUE)
  
  if (length(files) == 0) {
    return(NULL)
  }
  
  # Récupérer la date du fichier le plus récent
  latest_date <- file.info(files)$mtime[which.max(file.info(files)$mtime)]
  
  # Formater la date en français
  formatted_date <- format(latest_date, 
                         format = "%H:%M",
                         tz = "Europe/Paris")
  
  return(formatted_date)
}

```

# Bienvenue

## Row {height=30%}

```{r}
#| content: "valuebox"
#| title: "Nombre d'observations complètes saisies"

list(
icon = "pencil-fill", 
# color = "white",
value = data |> 
  distinct(person_id, timestamp) |> 
  nrow()
)

```

```{r}
#| content: "valuebox"
#| title: "Nombre de groupes impliqués"

list(
icon = "house", 
# color = "white",
value = data |> 
  distinct(group_id) |> 
  nrow()
)

```

```{r}
#| content: "valuebox"
#| title: "Données mise à jour à"


list(
  icon = "calendar-check",
  #color = "white",
  value = get_survey_data_update_date()
)

```

## Row {height=70%}

```{r}
#| echo: false
#| output: asis

scales_list <- data %>%
  select(scale_label) %>%
  distinct() %>%
  pull() %>%
  sort()

# Créer des cartes en colonnes
cat("::: {.grid}\n\n")

for(scale in scales_list) {
  cat(sprintf("::: {.g-col-4}\n::: {.card}\n%s\n:::\n:::\n\n", scale))
}

cat(":::\n")
```

# Espace profs

## Row {height=30%}

```{r}
#| title: "identification"

textInput("teacher_id", 
          "Votre identifiant personnel",
          placeholder = "Par exemple: 01NS14-artichaut")

uiOutput("id_status")

```


```{r}
value_box(
  title = "Nombre de saisies concernées",
  value = textOutput("Observations"),
  showcase = bs_icon("pencil-fill")

)
```



```{r}
value_box(
  title = "Groupe de référence",
  value = textOutput("GroupeRef"),
  showcase = bs_icon("house")
)
```


```{r}
#| content: "valuebox"
#| title: "Données mise à jour à"

list(
  color = "morph",
  value = get_survey_data_update_date(),
  icon = "calendar-check"
)

```

## Row {height=70%}


### {.toolbar} {width=30%}


```{r}
#| title: "Commandes"

uiOutput("scale_choices")

# UI conditionnelle pour les scores disponibles
uiOutput("score_choices")

```

### {.tabset}

```{r}
#| title: "Plot"

plotlyOutput("scale_plot")

```


```{r}
#| title: "Table"

DTOutput("scale_table")

```


# Espace direction

## Row {height=30%}

```{r}
#| title: "identification"
textInput("group_id", 
          "Code de l'établissement",
          placeholder = "Par exemple: un")

uiOutput("group_id_status")
```

```{r}
value_box(
  title = "Nombre d'observations",
  value = textOutput("GroupObservations"),
  showcase = bs_icon("pencil-fill")

)
```

```{r}
value_box(
  title = "Nombre d'utilisateurs",
  value = textOutput("GroupUsers"),
  showcase = bs_icon("people-fill")

)
```

```{r}
#| content: "valuebox"
#| title: "Données mise à jour à"

list(
  color = "morph",
  value = get_survey_data_update_date(),
  icon = "calendar-check"
)

```

## Row {height=70%}

### {.toolbar} {width=30%}

```{r}
#| title: "Commandes de groupe"
uiOutput("group_scale_choices")
uiOutput("group_score_choices")
```

### {.tabset}

```{r}
#| title: "Plot"

plotlyOutput("group_scale_plot")

```

```{r}
#| title: "Table"

DTOutput("group_scale_table")

```

# Espace recherche

## {.toolbar}

```{r}
selectInput("demo_age", "Âge", 
 choices = c("Tous", unique(data$age)),
 selected = "Tous"
)
```

```{r}
selectInput("demo_gender", "Genre",
 choices = c("Tous", unique(data$gender)), 
 selected = "Tous"
)
```

```{r}
selectInput("demo_status", "Statut",
 choices = c("Tous", unique(data$status)),
 selected = "Tous"
)
```

```{r}
selectInput("demo_exp", "Expérience",
 choices = c("Tous", unique(data$experience)),
 selected = "Tous"
)
```

```{r}
uiOutput("research_scale_choices")
```

```{r}
uiOutput("research_score_choices")
```

## Row {height=70%}

### {.tabset} 

#### Plots
```{r}
plotlyOutput("research_plot")
```

#### Table

```{r}
DTOutput("research_table")
```

```{r}
#| context: server

# Espace enseignant----

# Données réactives pour l'id de l'enseignant (même person_id dans le bon group_id)
teacher_data <- reactive({
  req(input$teacher_id)
  validate(need(nchar(input$teacher_id) > 0, "Veuillez saisir un identifiant"))
  
  # D'abord trouver le matching avec l'ID sécurisé pour obtenir person_id et group_id
  secure_match <- data %>%
    filter(person_id_secure == input$teacher_id) %>%
    distinct(person_id, group_id) %>%
    head(1)  # On prend le premier match si plusieurs
  
  validate(need(nrow(secure_match) > 0, 
               "Identifiant non reconnu. Vérifiez votre saisie (exemple: 01NS14-banane)"))
  
  # Ensuite filtrer toutes les données correspondant à ce person_id dans ce group_id
  filtered_data <- data %>%
    filter(
      person_id == secure_match$person_id,
      group_id == secure_match$group_id,
      score_value != -99
    )
  
  filtered_data
})

# UI dynamique pour le choix d'échelle 
output$scale_choices <- renderUI({
  req(teacher_data())
  
  selectInput(
    "selected_scale", 
    "Échelle à visualiser :",
    choices = unique(teacher_data()$scale_label),
    selected = NULL
  )
})

# UI dynamique pour les choix de scores
output$score_choices <- renderUI({
  req(teacher_data(), input$selected_scale)
  
  scores <- teacher_data() %>%
    filter(scale_label == input$selected_scale) %>%
    pull(score_type_label) %>%
    unique()
  
  checkboxGroupInput(
    "selected_scores",
    "Scores à afficher :",
    choices = scores,
    selected = scores[1]
  )
})

# Enseignant - Plot des données
output$scale_plot <- renderPlotly({
  req(teacher_data(), input$selected_scale, input$selected_scores)
  
  plot_data <- teacher_data() %>%
    filter(
      scale_label == input$selected_scale,
      score_type_label %in% input$selected_scores
    )
  
  reference_segments <- plot_data %>% 
    group_by(month, score_type_label) %>%
    summarise(
      reference_value = first(reference_value),
      start = floor_date(min(timestamp), "month"),
      end = ceiling_date(min(timestamp), "month") - days(1),
      .groups = "drop"
    )
  
  validate(need(nrow(plot_data) > 0, "Aucune donnée à afficher"))
  
  p <- ggplot() +
    geom_segment(
      data = reference_segments,
      aes(x = start, xend = end,
          y = reference_value, yend = reference_value,
          color = score_type_label),
      linewidth = 1
    ) +
    geom_line(
      data = plot_data,
      aes(x = timestamp, y = score_value, color = score_type_label),
      linewidth = 1
    ) +
    geom_point(
      data = plot_data,
      aes(x = timestamp, y = score_value, color = score_type_label),
      size = 3
    ) +
    labs(
      x = "Date",
      y = "Valeur",
      color = "Score"
    ) +
    scale_x_date(date_labels = "%B", date_breaks = "1 month") +
    theme_minimal()
  
  ggplotly(p, config = list(displayModeBar = FALSE)) |>
  layout(
    paper_bgcolor = "rgba(0,0,0,0)", 
    plot_bgcolor = "rgba(0,0,0,0)",
    font = list(color = "rgb(33, 37, 41)"),
    xaxis = list(
      gridcolor = "rgba(128,128,128,0.2)",
      zerolinecolor = "rgba(128,128,128,0.2)"
    ),
    yaxis = list(
      gridcolor = "rgba(128,128,128,0.2)", 
      zerolinecolor = "rgba(128,128,128,0.2)"
    )
  )
})

# Enseignant - Table des données
output$scale_table <- renderDT({
 req(teacher_data(), input$selected_scale, input$selected_scores)
 
 table_data <- teacher_data() %>%
   filter(
     scale_label == input$selected_scale,
     score_type_label %in% input$selected_scores
   ) %>%
   select(
     timestamp,
     score_type_label,
     score_value,
     reference_value, 
     reference_sd,
     quartile,
     n_group
   )
 
 validate(need(nrow(table_data) > 0, "Aucune donnée à afficher"))
 
 table_data %>%
   rename(
     "Date" = timestamp,
     "Type de score" = score_type_label,
     "Score personnel" = score_value,
     "Moyenne du groupe" = reference_value,
     "Écart-type" = reference_sd,
     "Quartile" = quartile,
     "N" = n_group
   ) %>%
   arrange(desc(`Date`)) %>%  # Plus récent en premier
   datatable(
     options = list(
       pageLength = 10,
       dom = 't',
       ordering = FALSE
     ),
     rownames = FALSE
   ) %>%
   formatRound(
     columns = c("Score personnel", "Moyenne du groupe", "Écart-type"),
     digits = 2
   ) %>%
   formatDate(
     columns = "Date",
     method = "toLocaleDateString"
   )
})

output$Observations <- renderText({
  teacher_data() |> 
    distinct(timestamp) |>
    nrow()
})

output$GroupeRef <- renderText({
  teacher_data() |> 
    pull(group_id) |>
    unique() |>
    first()
})

# espace direction----

# Données réactives pour le groupe
group_data <- reactive({
  req(input$group_id)
  validate(need(nchar(input$group_id) > 0, "Veuillez saisir un code établissement"))
  
  filtered_data <- data %>%
    filter(group_id == input$group_id)
  
  validate(need(nrow(filtered_data) > 0, "Aucune donnée pour cet établissement"))
  
  filtered_data
})

# Calcul des moyennes de référence (tous groupes)
reference_data <- reactive({
  req(group_data())
  
  data %>%
    group_by(month, scale_label, score_type_label) %>%
    summarise(
      reference_value = mean(score_value, na.rm = TRUE),
      reference_sd = sd(score_value, na.rm = TRUE),
      n_total = n(),
      .groups = "drop"
    )
})

# UI pour choix d'échelle
output$group_scale_choices <- renderUI({
  req(group_data())
  
  selectInput(
    "selected_group_scale", 
    "Échelle à visualiser :",
    choices = unique(group_data()$scale_label),
    selected = NULL
  )
})

# UI pour choix de scores
output$group_score_choices <- renderUI({
  req(group_data(), input$selected_group_scale)
  
  scores <- group_data() %>%
    filter(scale_label == input$selected_group_scale) %>%
    pull(score_type_label) %>%
    unique()
  
  checkboxGroupInput(
    "selected_group_scores",
    "Scores à afficher :",
    choices = scores,
    selected = scores[1]
  )
})

# Plot des données de groupe
output$group_scale_plot <- renderPlotly({
  req(group_data(), reference_data(), 
      input$selected_group_scale, input$selected_group_scores)
  
  # Moyennes du groupe
  group_means <- group_data() %>%
    filter(
      scale_label == input$selected_group_scale,
      score_type_label %in% input$selected_group_scores
    ) %>%
    group_by(month, scale_label, score_type_label) %>%
    summarise(
      group_mean = mean(score_value, na.rm = TRUE),
      n_group = n(),
      .groups = "drop"
    )
  
  # Joindre avec les références
  plot_data <- group_means %>%
    left_join(reference_data(), 
              by = c("month", "scale_label", "score_type_label"))
  
  validate(need(nrow(plot_data) > 0, "Aucune donnée à afficher"))
  
  p <- plot_data %>%
    ggplot() +
    # Ligne groupe
    geom_line(aes(x = month, y = group_mean, 
                  color = score_type_label)) +
    geom_point(aes(x = month, y = group_mean, 
                   color = score_type_label, 
                   text = sprintf("N=%d", n_group))) +
    # Ligne référence en pointillé FAIL
    geom_hline(aes(yintercept = reference_value,
                  color = score_type_label),
              linetype = "dashed") +
    labs(
      x = "Période",
      y = "Score moyen",
      color = "Type de score"
    ) +
    theme_minimal()
    
  ggplotly(p, tooltip = "text")
})

# Table des données de groupe
output$group_scale_table <- renderDT({
  req(group_data(), reference_data(),
      input$selected_group_scale, input$selected_group_scores)
  
  group_means <- group_data() %>%
    filter(
      scale_label == input$selected_group_scale,
      score_type_label %in% input$selected_group_scores
    ) %>%
    group_by(month, scale_label, score_type_label) %>%
    summarise(
      group_mean = mean(score_value, na.rm = TRUE),
      n_group = n(),
      .groups = "drop"
    )
  
  table_data <- group_means %>%
    left_join(reference_data(),
              by = c("month", "scale_label", "score_type_label")) %>%
    select(
      month,
      score_type_label,
      group_mean,
      reference_value,
      reference_sd,
      n_group,
      n_total
    )
  
  validate(need(nrow(table_data) > 0, "Aucune donnée à afficher"))
  
  table_data %>%
    rename(
      "Mois" = month,
      "Type de score" = score_type_label,
      "Moyenne du groupe" = group_mean,
      "Moyenne globale" = reference_value,
      "Écart-type global" = reference_sd,
      "N groupe" = n_group,
      "N total" = n_total
    ) %>%
    arrange(desc(`Mois`)) %>%
    datatable(
      options = list(
        pageLength = 10,
        dom = 't',
        ordering = FALSE
      ),
      rownames = FALSE
    ) %>%
    formatRound(
      columns = c("Moyenne du groupe", "Moyenne globale", "Écart-type global"),
      digits = 2
    )
})
# Nombre d'observations
output$GroupObservations <- renderText({
  group_data() %>% 
    distinct(timestamp, person_id) %>%  # On ne compte qu'une fois par mois et par personne
    nrow()
})

# Nombre d'utilisateurs uniques
output$GroupUsers <- renderText({
  group_data() %>%
    distinct(person_id) %>%
    nrow()
})

# Espace recherche----

filtered_research_data <- reactive({
 data %>%
   filter(
     if(input$demo_age != "Tous") age == input$demo_age else TRUE,
     if(input$demo_gender != "Tous") gender == input$demo_gender else TRUE,  
     if(input$demo_status != "Tous") status == input$demo_status else TRUE,
     if(input$demo_exp != "Tous") experience == input$demo_exp else TRUE
   )
})

output$research_plot <- renderPlotly({
 req(filtered_research_data(), input$research_scale, input$research_scores)
 
 plot_data <- filtered_research_data() %>%
   filter(
     scale_label == input$research_scale,
     score_type_label %in% input$research_scores
   )
 
 p <- ggplot(plot_data) +
   geom_boxplot(aes(x = month, y = score_value, fill = score_type_label)) +
   labs(x = "Période", y = "Score", fill = "Type de score") +
   theme_minimal() +
   coord_flip()
 
 ggplotly(p)
})

output$research_table <- renderDT({
 req(filtered_research_data(), input$research_scale, input$research_scores)
 
 filtered_research_data() %>%
   filter(
     scale_label == input$research_scale,
     score_type_label %in% input$research_scores
   ) %>%
   group_by(month, score_type_label) %>%
   summarise(
     N = n(),
     Moyenne = mean(score_value, na.rm = TRUE),
     "Écart-type" = sd(score_value, na.rm = TRUE),
     Min = min(score_value, na.rm = TRUE),
     Max = max(score_value, na.rm = TRUE)
   ) %>%
   arrange(desc(month))
})

```