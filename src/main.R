source("src/lib/connection.R")
source("src/lib/import.R")
source("src/lib/scales.R")
source("src/lib/demographics.R")

library(glue)

# Chargement config
config <- yaml::read_yaml("src/config/scales.yml")
credentials <- yaml::read_yaml("src/config/credentials.yml")
survey_id <- credentials$limesurvey$survey_id
groups_config <- yaml::read_yaml("src/config/groups.yml")

# Pr√©paration du log
log_info <- function(msg) {
  log_dir <- "logs"
  if (!dir.exists(log_dir)) {
    dir.create(log_dir, recursive = TRUE)
  }
  cat(glue("[{Sys.time()}] {msg}\n\n"), 
      file = file.path(log_dir, "process.log"), 
      append = TRUE)
}

# Fonction de gestion des labels de groupes et sous-groupes

get_group_labels <- function(groups_config) {

  # Cr√©ation d'une liste pour les labels de groupes
  group_labels <- tibble(
    group_id = names(groups_config),
    group_label = map_chr(groups_config, ~.x$label)
  )
  
  # Cr√©ation d'une liste pour les labels de sous-groupes
  subgroup_labels <- tibble(
    group_id = rep(names(groups_config), 
                   map_int(groups_config, ~length(.x$subgroups %||% list()))),
    subgroup_id = unlist(map(groups_config, 
                             ~names(.x$subgroups %||% list()))),
    subgroup_label = unlist(map(groups_config, 
                                ~map_chr(.x$subgroups %||% list(), ~.x$label)))
  )
  
  list(
    group_labels = group_labels,
    subgroup_labels = subgroup_labels
  )
}

# Fonction pour envoyer des messages Telegram
send_telegram_notification <- function(message, bot_token, chat_id) {
  if (!startsWith(as.character(chat_id), "-100")) {
    chat_id <- paste0("-100", gsub("-", "", chat_id))
  }
  
  url <- paste0("https://api.telegram.org/bot", bot_token, "/sendMessage")
  
  body <- list(
    chat_id = chat_id,
    text = message,
    parse_mode = "HTML"
  )
  
  tryCatch({
    response <- httr::POST(
      url = url,
      body = body,
      encode = "json"
    )
    return(httr::status_code(response) == 200)
  }, error = function(e) {
    return(FALSE)
  })
}

# Pipeline principal
main <- function(survey_id, credentials, groups_config) {
  start_time <- Sys.time()
  status <- "‚úÖ Succ√®s"
  error_msg <- NULL
  n_rows <- 0
  n_scales <- 0
  n_scores <- 0
  n_administration <- 0
  
  tryCatch({
    log_info("\nD√©marrage du traitement")
    
    # 1. Connection
    log_info("\nTentative de connexion √† LimeSurvey")
    if(!setup_limesurvey_connection(credentials)) {
      stop("√âchec de connexion LimeSurvey")
    }
    log_info("\nConnexion √©tablie")
    
    # 2. Import et standardisation  
    log_info("\nImport des donn√©es brutes")
    raw_data <- get_limesurvey_data(survey_id, config)
    log_info(glue("\nImport termin√©: {nrow(raw_data)} lignes"))
    
    log_info("\nStandardisation des noms")
    std_data <- standardize_limesurvey_names(raw_data, config)
    log_info("\nStandardisation termin√©e")
    
    # 3. Traitement des √©chelles et des donn√©es d√©mographiques en parall√®le
    log_info("\nCalcul des scores")
    scales_data <- prepare_all_scales_scores(std_data, config)
    n_rows <- nrow(scales_data)
    # Nombre d'√©chelles prises en compte
    n_scales <- scales_data |> 
      distinct(scale_label) |> 
      nrow()
    # Nombre de scores diff√©rents calcul√©s, bas√© sur scale_label et score_type_label
    n_scores <- scales_data |> 
      distinct(scale_label, score_type_label) |> 
      nrow()
    # Nombre de passations bas√©es sur person_id_secure et timestamp
    n_administration <- scales_data |> 
      distinct(person_id_secure, timestamp) |> 
      nrow()
    log_info(glue("\nCalcul termin√©: {n_rows} lignes"))
    log_info("\nPr√©paration des donn√©es d√©mographiques")
    demographics_data <- process_demographics(std_data, config)
    log_info("\nPr√©paration termin√©e")

    # 4. Joindre les donn√©es
    log_info("\nCr√©ation de processed_data")
    processed_data <- scales_data %>%
      left_join(
        demographics_data,
        by = c(
          "person_id_secure",
          "timestamp", 
          "month",
          "group_id",
          "subgroup_id"
        )
      )
    log_info("\nJointure termin√©e")
    
    # 5. Ajout des labels de groupe
    log_info("\nAjout des labels de groupe")
    labels_data <- get_group_labels(groups_config)
    processed_data <- processed_data %>%
      left_join(
        labels_data$group_labels,
        by = "group_id"
      ) %>%
      left_join(
        labels_data$subgroup_labels,
        by = c("group_id", "subgroup_id")
      )
    
    log_info("\nJointure termin√©e")
    
    # Ajout de la colonne reseacher id pour chaque observation avec credentials$researcher_codes[1]
    log_info("\nCr√©ation de researcher_id")
    processed_data$researcher_id <- credentials$researcher_codes[1]
    log_info("\nCr√©ation de researcher_id termin√©e")
    
    # 6. Export avec timestamp
    output_dir <- "data/processed"
    if (!dir.exists(output_dir)) {
      dir.create(output_dir, recursive = TRUE)
      log_info("\nCr√©ation du dossier de sortie")
    }
    
    timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
    output_file <- file.path(output_dir, glue("survey_data_{timestamp}.csv"))
    write_csv(processed_data, output_file)
    log_info(glue("\nDonn√©es export√©es: {output_file}"))
    
    log_info("\nTraitement termin√© avec succ√®s")
    
  }, error = function(e) {
    status <- "‚ùå √âchec"
    error_msg <- conditionMessage(e)
    log_info(glue("\nERREUR: {error_msg}"))
  }, finally = {
    # Pr√©paration du message Telegram
    # Calcul simple en secondes
    duration <- sprintf("%.1f secondes", 
                        as.numeric(difftime(Sys.time(), start_time, units = "secs")))
    
    message <- glue("
ü§ñ Mise √† jour LimeSurvey

Status: {status}
Temps d'ex√©cution: {duration}
Observations: {n_rows}
Echelles: {n_scales}
Scores: {n_scores}
Passations: {n_administration}
{if(!is.null(error_msg)) paste('Erreur:', error_msg) else ''}
    ")
    
    # Envoi de la notification Telegram
    send_telegram_notification(
      message,
      bot_token = credentials$telegram$bot_token,
      chat_id = credentials$telegram$chat_id
    )
  })
}

# Ex√©cution
main(survey_id, credentials, groups_config)